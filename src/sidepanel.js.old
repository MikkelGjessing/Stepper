// Side Panel Main Script
// Orchestrates UI interactions and module coordination

// Import modules
import { FeatureFlags, isFeatureEnabled, setFeatureFlag } from './modules/config.js';
import { MockRetrievalProvider } from './modules/retrieval.js';
import { mockArticles } from './modules/kb.mock.js';
import { StepRunner } from './modules/stepRunner.js';
import { createPageScanner } from './modules/pageScanner.js';
import { 
  showNotification, 
  formatReason,
  renderArticleItem,
  renderCompletedStep,
  renderFailureNote,
  populateFullArticle,
  updateStepProgress,
  renderSteppingStones,
  toggleElement,
  clearElement,
  escapeHtml
} from './modules/ui.js';

// Constants
const MAX_FALLBACK_QUERY_LENGTH = 50; // Maximum characters for fallback search query
const THEME_STORAGE_KEY = 'stepper_playful_theme_enabled';

// Initialize modules
const retrieval = new MockRetrievalProvider(mockArticles);
const stepRunner = new StepRunner();
const pageScanner = createPageScanner('default'); // Disabled by default
let currentArticle = null;
let scannedPageContent = null; // Store scanned page content
let extractedContext = new Map(); // Store extracted label-value pairs from page scan
let previousStepIndex = -1; // Track previous step for animation

// DOM Elements
const chatView = document.getElementById('chat-view');
const chatMessages = document.getElementById('chat-messages');
const chatInput = document.getElementById('chat-input');
const sendButton = document.getElementById('send-button');
const steppingStonesContainer = document.getElementById('stepping-stones-container');
const articleSearch = document.getElementById('article-search');
const resetButton = document.getElementById('reset-button');
const themeToggleButton = document.getElementById('theme-toggle-button');

// Modals
const failureModal = document.getElementById('failure-modal');
const closeFailureModal = document.getElementById('close-failure-modal');
const cancelFailure = document.getElementById('cancel-failure');
const failureForm = document.getElementById('failure-form');
const failureReason = document.getElementById('failure-reason');
const failureNote = document.getElementById('failure-note');

// Chat state
let chatState = 'initial'; // initial, searching, in-step, completed
let currentContinueButton = null;

// Initialize UI
async function init() {
  // Log feature flags
  console.log('[Stepper] Feature flags:', FeatureFlags);
  
  // Load theme preference from localStorage
  loadThemePreference();
  
  // Show welcome message
  showWelcomeMessage();
  
  setupEventListeners();
  
  // Log module initialization
  console.log('[Stepper] Modules initialized');
}

// ==================== CHAT FUNCTIONS ====================

/**
 * Show welcome message in chat
 */
function showWelcomeMessage() {
  addAssistantMessage('Hello! I\'m here to help you troubleshoot issues step by step. What problem are you experiencing?');
}

/**
 * Add a message to the chat
 * @param {string} text - Message text
 * @param {string} sender - 'agent' or 'assistant'
 * @param {HTMLElement} customContent - Optional custom content to append
 */
function addChatMessage(text, sender, customContent = null) {
  const messageDiv = document.createElement('div');
  messageDiv.className = `chat-message ${sender}`;
  
  const senderLabel = document.createElement('div');
  senderLabel.className = 'message-sender';
  senderLabel.textContent = sender === 'agent' ? 'You' : 'Assistant';
  
  const bubble = document.createElement('div');
  bubble.className = 'message-bubble';
  
  if (text) {
    const textP = document.createElement('p');
    textP.textContent = text;
    bubble.appendChild(textP);
  }
  
  if (customContent) {
    bubble.appendChild(customContent);
  }
  
  messageDiv.appendChild(senderLabel);
  messageDiv.appendChild(bubble);
  chatMessages.appendChild(messageDiv);
  
  // Scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  return messageDiv;
}

/**
 * Add agent message
 */
function addAgentMessage(text) {
  return addChatMessage(text, 'agent');
}

/**
 * Add assistant message
 */
function addAssistantMessage(text, customContent = null) {
  return addChatMessage(text, 'assistant', customContent);
}

/**
 * Show typing indicator
 */
function showTypingIndicator() {
  const indicator = document.createElement('div');
  indicator.className = 'typing-indicator';
  indicator.innerHTML = '<span></span><span></span><span></span>';
  
  const message = addAssistantMessage(null, indicator);
  message.id = 'typing-indicator-message';
  
  return message;
}

/**
 * Remove typing indicator
 */
function removeTypingIndicator() {
  const indicator = document.getElementById('typing-indicator-message');
  if (indicator) {
    indicator.remove();
  }
}

/**
 * Handle user input
 */
async function handleUserInput() {
  const query = chatInput.value.trim();
  if (!query) return;
  
  // Add agent message
  addAgentMessage(query);
  
  // Clear input
  chatInput.value = '';
  chatInput.disabled = true;
  
  // Show typing
  showTypingIndicator();
  
  // Simulate typing delay
  await new Promise(resolve => setTimeout(resolve, 800));
  
  // Search for matching articles
  const articles = await retrieval.search(query);
  
  removeTypingIndicator();
  
  if (articles.length === 0) {
    addAssistantMessage('I couldn\'t find any articles matching your issue. Could you try describing it differently?');
    chatInput.disabled = false;
    chatInput.focus();
  } else if (articles.length === 1) {
    // Single match - start directly
    const article = articles[0];
    addAssistantMessage(`I found a solution: "${article.title}". This solution has ${article.steps.length} steps. Let's begin!`);
    
    // Start article
    await selectArticleInChat(article.id);
  } else {
    // Multiple matches - show as cards
    const cardsContainer = document.createElement('div');
    cardsContainer.className = 'article-cards-container';
    
    articles.slice(0, 5).forEach(article => {
      const card = createArticleCard(article);
      cardsContainer.appendChild(card);
    });
    
    addAssistantMessage(`I found ${articles.length} possible solutions. Please select the one that best matches your issue:`, cardsContainer);
    chatInput.disabled = true;
  }
}

/**
 * Create article card for selection
 */
function createArticleCard(article) {
  const card = document.createElement('div');
  card.className = 'article-card';
  
  const title = document.createElement('h4');
  title.textContent = article.title;
  card.appendChild(title);
  
  const summary = document.createElement('p');
  summary.textContent = article.summary;
  card.appendChild(summary);
  
  const tags = document.createElement('div');
  tags.className = 'article-tags';
  article.tags.slice(0, 3).forEach(tag => {
    const tagSpan = document.createElement('span');
    tagSpan.className = 'tag';
    tagSpan.textContent = tag;
    tags.appendChild(tagSpan);
  });
  card.appendChild(tags);
  
  card.addEventListener('click', () => selectArticleInChat(article.id));
  
  return card;
}

/**
 * Select article and begin steps in chat
 */
async function selectArticleInChat(articleId) {
  currentArticle = await retrieval.getArticle(articleId);
  if (!currentArticle) return;
  
  stepRunner.startArticle(articleId, currentArticle);
  chatState = 'in-step';
  
  // Show stepping stones
  showSteppingStonesProgress();
  
  // Show first step
  showCurrentStepInChat();
}

/**
 * Show stepping stones progress indicator
 */
function showSteppingStonesProgress() {
  if (isFeatureEnabled('ENABLE_PLAYFUL_THEME')) {
    steppingStonesContainer.style.display = 'block';
    updateSteppingStonesInChat();
  }
}

/**
 * Update stepping stones indicator
 */
function updateSteppingStonesInChat() {
  const state = stepRunner.getState();
  const totalSteps = stepRunner.getTotalSteps(currentArticle);
  const currentStep = state.currentStepIndex + 1;
  
  if (isFeatureEnabled('ENABLE_PLAYFUL_THEME')) {
    const shouldAnimate = previousStepIndex >= 0 && state.currentStepIndex > previousStepIndex;
    renderSteppingStones(steppingStonesContainer, currentStep, totalSteps, shouldAnimate);
    previousStepIndex = state.currentStepIndex;
  }
}

/**
 * Show current step in chat
 */
function showCurrentStepInChat() {
  const step = stepRunner.getCurrentStep(currentArticle);
  const state = stepRunner.getState();
  
  if (!step || stepRunner.isComplete(currentArticle)) {
    showCompletionInChat();
    return;
  }
  
  // Update stepping stones
  updateSteppingStonesInChat();
  
  // Create step content
  const stepContent = document.createElement('div');
  stepContent.className = 'step-message';
  
  const stepText = document.createElement('div');
  stepText.className = 'step-text';
  stepText.innerHTML = augmentTextWithContext(step.text);
  stepContent.appendChild(stepText);
  
  // Add expected result if present
  if (step.expectedResult) {
    const expectedDiv = document.createElement('div');
    expectedDiv.className = 'expected-outcome-inline';
    
    const label = document.createElement('div');
    label.className = 'outcome-label';
    label.textContent = 'Expected Outcome';
    expectedDiv.appendChild(label);
    
    const text = document.createElement('div');
    text.className = 'outcome-text';
    text.innerHTML = augmentTextWithContext(step.expectedResult);
    expectedDiv.appendChild(text);
    
    stepContent.appendChild(expectedDiv);
  }
  
  // Add action buttons
  const actions = document.createElement('div');
  actions.className = 'step-actions-inline';
  
  const continueBtn = document.createElement('button');
  continueBtn.className = 'btn btn-primary';
  continueBtn.textContent = 'Continue â†’';
  continueBtn.addEventListener('click', handleContinueInChat);
  currentContinueButton = continueBtn;
  actions.appendChild(continueBtn);
  
  if (state.currentStepIndex > 0) {
    const backBtn = document.createElement('button');
    backBtn.className = 'btn btn-secondary';
    backBtn.textContent = 'â† Back';
    backBtn.addEventListener('click', handleBackInChat);
    actions.appendChild(backBtn);
  }
  
  const didntWorkBtn = document.createElement('button');
  didntWorkBtn.className = 'btn btn-warning';
  didntWorkBtn.textContent = 'This didn\'t work';
  didntWorkBtn.addEventListener('click', handleDidntWorkInChat);
  actions.appendChild(didntWorkBtn);
  
  stepContent.appendChild(actions);
  
  // Add step to chat
  const stepNumber = state.currentStepIndex + 1;
  const totalSteps = stepRunner.getTotalSteps(currentArticle);
  addAssistantMessage(`Step ${stepNumber} of ${totalSteps}:`, stepContent);
}

/**
 * Handle continue in chat
 */
function handleContinueInChat() {
  // Disable the button to prevent double clicks
  if (currentContinueButton) {
    currentContinueButton.disabled = true;
  }
  
  const result = stepRunner.continue(currentArticle);
  
  if (result.completed) {
    showCompletionInChat();
  } else {
    showCurrentStepInChat();
  }
}

/**
 * Handle back in chat
 */
function handleBackInChat() {
  const result = stepRunner.back();
  
  if (result.success) {
    // Just update display, don't add new message
    // Instead, scroll to the previous step message
    addAssistantMessage('Going back to the previous step.');
    showCurrentStepInChat();
  }
}

/**
 * Handle didn't work in chat
 */
function handleDidntWorkInChat() {
  failureModal.style.display = 'flex';
  failureReason.value = '';
  failureNote.value = '';
}

/**
 * Show completion in chat
 */
function showCompletionInChat() {
  const summary = stepRunner.getCompletionSummary();
  
  let message = 'âœ… Process complete! ';
  if (summary.failureHistory.length > 0) {
    message += `You completed all steps with ${summary.failureHistory.length} issue(s) reported.`;
  } else {
    message += 'You completed all steps successfully!';
  }
  
  addAssistantMessage(message);
  
  chatState = 'completed';
  chatInput.disabled = false;
  chatInput.placeholder = 'Describe another issue...';
  chatInput.focus();
  
  // Hide stepping stones
  steppingStonesContainer.style.display = 'none';
  previousStepIndex = -1;
}

// ==================== HELPER FUNCTIONS ====================

/**
 * Augment text with extracted context values
 * Detects mentions of context labels and appends their values
 * @param {string} text - Text to augment (step text or expected result)
 * @returns {string} Augmented HTML with context hints
 */
function augmentTextWithContext(text) {
  if (!text || extractedContext.size === 0) {
    return escapeHtml(text);
  }
  
  const contextHints = [];
  
  // Pre-compile regexes for efficiency
  const labelRegexes = new Map();
  extractedContext.forEach((value, label) => {
    const escapedLabel = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    labelRegexes.set(label, new RegExp(`\\b${escapedLabel}\\b`, 'i'));
  });
  
  // Check if any context labels are mentioned in the text (case-insensitive)
  extractedContext.forEach((value, label) => {
    const labelRegex = labelRegexes.get(label);
    
    if (labelRegex.test(text)) {
      contextHints.push(`${escapeHtml(label)}: ${escapeHtml(value)}`);
    }
  });
  
  // Build HTML with context hints styled differently
  let html = escapeHtml(text);
  
  if (contextHints.length > 0) {
    html += ` <span class="context-hint">(Stepper found: ${contextHints.join(', ')})</span>`;
  }
  
  return html;
}

// ==================== OLD FUNCTIONS (kept for failure modal compatibility) ====================

/**
 * Extract a search query from scanned page content
 * @param {PageContent} content - Scanned page content
 * @returns {string} Search query
 */
function extractSearchQuery(content) {
  // Use metadata if available
  if (content.metadata?.product) {
    return content.metadata.product;
  }
  
  // Extract key terms from page text
  const text = content.text || '';
  
  // Look for common product/issue keywords
  const keywords = [
    'gmail', 'outlook', 'email', 
    'network', 'wifi', 'internet', 'connection',
    'windows', 'mac', 'linux',
    'installation', 'install', 'setup',
    'error', 'failed', 'not working'
  ];
  
  const lowerText = text.toLowerCase();
  const foundKeywords = keywords.filter(keyword => lowerText.includes(keyword));
  
  // Return the first few keywords or first sentence
  if (foundKeywords.length > 0) {
    return foundKeywords.slice(0, 2).join(' ');
  }
  
  // Fallback: first MAX_FALLBACK_QUERY_LENGTH characters
  return text.substring(0, MAX_FALLBACK_QUERY_LENGTH).trim();
}

/**
 * Augment text with extracted context values
 * Detects mentions of context labels and appends their values
 * @param {string} text - Text to augment (step text or expected result)
 * @returns {string} Augmented HTML with context hints
 */
function augmentTextWithContext(text) {
  if (!text || extractedContext.size === 0) {
    return escapeHtml(text);
  }
  
  const contextHints = [];
  
  // Pre-compile regexes for efficiency
  const labelRegexes = new Map();
  extractedContext.forEach((value, label) => {
    const escapedLabel = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    labelRegexes.set(label, new RegExp(`\\b${escapedLabel}\\b`, 'i'));
  });
  
  // Check if any context labels are mentioned in the text (case-insensitive)
  extractedContext.forEach((value, label) => {
    const labelRegex = labelRegexes.get(label);
    
    if (labelRegex.test(text)) {
      contextHints.push(`${escapeHtml(label)}: ${escapeHtml(value)}`);
    }
  });
  
  // Build HTML with context hints styled differently
  let html = escapeHtml(text);
  
  if (contextHints.length > 0) {
    html += ` <span class="context-hint">(Stepper found: ${contextHints.join(', ')})</span>`;
  }
  
  return html;
}

// Render article list
async function renderArticleList() {
  clearElement(articleList);
  const articles = await retrieval.getAllArticles();
  
  articles.forEach(article => {
    const articleItem = renderArticleItem(article, () => selectArticle(article.id));
    articleList.appendChild(articleItem);
  });
}

// Select an article and start the stepper
async function selectArticle(articleId) {
  currentArticle = await retrieval.getArticle(articleId);
  if (!currentArticle) return;
  
  const startInfo = stepRunner.startArticle(articleId, currentArticle);
  
  // Switch to step runner view
  articleSelectionView.classList.remove('active');
  stepRunnerView.classList.add('active');
  
  // Update UI
  articleTitle.textContent = currentArticle.title;
  updateStepProgressIndicator();
  
  // Populate inline full article content
  populateFullArticleInline();
  
  // Show first step
  renderCurrentStep();
}

// Update step progress indicator
function updateStepProgressIndicator() {
  const state = stepRunner.getState();
  const totalSteps = stepRunner.getTotalSteps(currentArticle);
  const currentStep = state.currentStepIndex + 1;
  
  // Check if playful theme is enabled
  if (isFeatureEnabled('ENABLE_PLAYFUL_THEME')) {
    // Show stepping stones, hide text
    stepProgress.classList.add('hidden');
    steppingStonesContainer.classList.add('active');
    
    // Determine if we should animate (stepped forward)
    const shouldAnimate = previousStepIndex >= 0 && state.currentStepIndex > previousStepIndex;
    
    // Render stepping stones with animation
    renderSteppingStones(steppingStonesContainer, currentStep, totalSteps, shouldAnimate);
    
    // Update previous step index
    previousStepIndex = state.currentStepIndex;
  } else {
    // Show text, hide stepping stones
    stepProgress.classList.remove('hidden');
    steppingStonesContainer.classList.remove('active');
    
    // Update text progress
    updateStepProgress(stepProgress, currentStep, totalSteps);
  }
}

// Populate inline full article content
function populateFullArticleInline() {
  populateFullArticle(currentArticle, fullArticleContentInline);
}

// Render the current step
function renderCurrentStep() {
  const step = stepRunner.getCurrentStep(currentArticle);
  const state = stepRunner.getState();
  
  if (!step || stepRunner.isComplete(currentArticle)) {
    showCompletion();
    return;
  }
  
  // Show step card, hide completion
  stepCard.style.display = 'block';
  completionView.style.display = 'none';
  
  // Update step progress
  updateStepProgressIndicator();
  
  // Show skipped steps banner if applicable
  const skippedCount = stepRunner.getSkippedStepsCount();
  if (skippedCount > 0) {
    skippedStepsBanner.style.display = 'block';
    skippedStepsBanner.textContent = `Skipped ${skippedCount} step${skippedCount > 1 ? 's' : ''} already completed.`;
    // Clear the count so banner doesn't show on subsequent steps
    stepRunner.clearSkippedStepsCount();
  } else {
    skippedStepsBanner.style.display = 'none';
  }
  
  // Update step text (augment with context if available)
  stepText.innerHTML = augmentTextWithContext(step.text);
  
  // Update expected result
  if (step.expectedResult) {
    expectedResultContainer.style.display = 'block';
    expectedResult.innerHTML = augmentTextWithContext(step.expectedResult);
  } else {
    expectedResultContainer.style.display = 'none';
  }
  
  // Update say to customer
  if (step.sayToCustomer) {
    sayToCustomerContainer.style.display = 'block';
    sayToCustomer.textContent = step.sayToCustomer;
  } else {
    sayToCustomerContainer.style.display = 'none';
  }
  
  // Update back button state
  backButton.disabled = state.currentStepIndex === 0;
}

// Handle Continue button
function handleContinue() {
  const result = stepRunner.continue(currentArticle);
  
  if (result.completed) {
    showCompletion();
  } else {
    renderCurrentStep();
  }
}

// Handle Back button
function handleBack() {
  const result = stepRunner.back();
  
  if (result.success) {
    renderCurrentStep();
  }
}

// Handle "This didn't work" button
function handleDidntWork() {
  failureModal.style.display = 'flex';
  failureReason.value = '';
  failureNote.value = '';
}

// Handle failure form submission
async function handleFailureSubmit(e) {
  e.preventDefault();
  
  const step = stepRunner.getCurrentStep(currentArticle);
  const reason = failureReason.value;
  const note = failureNote.value;
  
  // Record the failure
  stepRunner.recordFailure(step.id, reason, note);
  
  failureModal.style.display = 'none';
  
  // Get all completed step texts for deduplication
  const completedStepTexts = [];
  const allSteps = currentArticle.steps || [];
  const state = stepRunner.getState();
  
  allSteps.forEach(s => {
    // Check Set membership using includes since getState() converts to Array
    if (state.completedStepIds.includes(s.id)) {
      completedStepTexts.push(s.text);
    }
  });
  
  // Select appropriate fallback
  const allArticles = await retrieval.getAllArticles();
  const fallbackResult = stepRunner.selectFallback(
    currentArticle,
    allArticles,
    reason,
    note
  );
  
  if (fallbackResult.type === 'same-article') {
    // Switch to fallback in same article
    const result = stepRunner.switchToFallback(
      fallbackResult.fallback.id,
      currentArticle,
      completedStepTexts
    );
    
    const message = result.skippedSteps > 0
      ? `Switching to alternative approach: ${fallbackResult.fallback.condition}\nSkipping ${result.skippedSteps} step(s) already completed.`
      : `Switching to alternative approach: ${fallbackResult.fallback.condition}`;
    
    showNotification(message, { type: 'info' });
    renderCurrentStep();
  } else if (fallbackResult.type === 'cross-article') {
    // Found fallback in different article
    const message = `Found alternative solution in "${fallbackResult.article.title}".\n\nWould you like to switch to this approach?`;
    
    if (showNotification(message, { requireConfirm: true })) {
      // Switch to the new article
      currentArticle = fallbackResult.article;
      articleTitle.textContent = currentArticle.title;
      
      const result = stepRunner.switchToFallback(
        fallbackResult.fallback.id,
        currentArticle,
        completedStepTexts
      );
      
      if (result.skippedSteps > 0) {
        showNotification(
          `Switched to new article. Skipping ${result.skippedSteps} step(s) already completed.`,
          { type: 'success' }
        );
      }
      
      renderCurrentStep();
    } else {
      showNotification('Issue recorded. You can continue with the next step or reset.', { type: 'info' });
    }
  } else if (fallbackResult.type === 'escalation') {
    // Show escalation guidance
    const escalation = fallbackResult.escalation;
    if (escalation) {
      showNotification(
        `No automated solution available.\n\nEscalation Required:\nWhen: ${escalation.when}\nTarget: ${escalation.target}`,
        { type: 'warning' }
      );
    } else {
      showNotification(
        'Issue recorded. No automated fallback available. Please escalate to appropriate support team.',
        { type: 'warning' }
      );
    }
  }
}

// Show completion summary
function showCompletion() {
  stepCard.style.display = 'none';
  completionView.style.display = 'block';
  
  const summary = stepRunner.getCompletionSummary();
  
  // Render completed steps
  const completedStepsList = document.getElementById('completed-steps-list');
  clearElement(completedStepsList);
  
  const steps = stepRunner.getStepsForActivePath(currentArticle);
  summary.completedSteps.forEach(stepId => {
    const step = steps.find(s => s.id === stepId);
    if (step) {
      completedStepsList.appendChild(renderCompletedStep(step));
    }
  });
  
  // Render failure notes if any
  const failureNotesContainer = document.getElementById('failure-notes');
  const failureNotesList = document.getElementById('failure-notes-list');
  
  if (summary.failureHistory.length > 0) {
    failureNotesContainer.style.display = 'block';
    clearElement(failureNotesList);
    
    summary.failureHistory.forEach(failure => {
      const step = steps.find(s => s.id === failure.stepId);
      failureNotesList.appendChild(renderFailureNote(failure, step));
    });
  } else {
    failureNotesContainer.style.display = 'none';
  }
}

// Handle reset
function handleReset() {
  if (confirm('Are you sure you want to reset? All progress will be lost.')) {
    stepRunner.reset();
    currentArticle = null;
    stepRunnerView.classList.remove('active');
    articleSelectionView.classList.add('active');
  }
}

// Handle back to articles
function handleBackToArticles() {
  stepRunnerView.classList.remove('active');
  articleSelectionView.classList.add('active');
  stepRunner.reset();
  currentArticle = null;
}

// Setup event listeners
function setupEventListeners() {
  // Button listeners
  continueButton.addEventListener('click', handleContinue);
  backButton.addEventListener('click', handleBack);
  didntWorkButton.addEventListener('click', handleDidntWork);
  resetButton.addEventListener('click', handleReset);
  backToArticlesButton.addEventListener('click', handleBackToArticles);
  themeToggleButton.addEventListener('click', handleThemeToggle);
  
  // Search functionality
  articleSearch.addEventListener('input', handleSearch);
  
  // Modal controls
  closeFailureModal.addEventListener('click', () => {
    failureModal.style.display = 'none';
  });
  cancelFailure.addEventListener('click', () => {
    failureModal.style.display = 'none';
  });
  failureForm.addEventListener('submit', handleFailureSubmit);
  
  // Close modals on background click
  failureModal.addEventListener('click', (e) => {
    if (e.target === failureModal) {
      failureModal.style.display = 'none';
    }
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', handleKeyboardShortcuts);
}

// Handle keyboard shortcuts
function handleKeyboardShortcuts(e) {
  // Esc to close modals
  if (e.key === 'Escape') {
    if (failureModal.style.display === 'flex') {
      failureModal.style.display = 'none';
      e.preventDefault();
    }
    return;
  }
  
  // Only handle Enter when not in a modal or text input
  if (e.key === 'Enter' && 
      failureModal.style.display !== 'flex' &&
      !e.target.matches('input, textarea, select')) {
    // Enter to continue (only in step runner view)
    if (stepRunnerView.classList.contains('active') && 
        !continueButton.disabled && 
        stepCard.style.display !== 'none') {
      continueButton.click();
      e.preventDefault();
    }
  }
}

// Handle article search
async function handleSearch(e) {
  const query = e.target.value.toLowerCase().trim();
  
  if (!query) {
    // Show all articles
    renderArticleList();
    return;
  }
  
  // Filter articles using retrieval module
  const filtered = await retrieval.filterArticles(query);
  
  // Render filtered list
  clearElement(articleList);
  filtered.forEach(article => {
    const articleItem = renderArticleItem(article, () => selectArticle(article.id));
    articleList.appendChild(articleItem);
  });
  
  if (filtered.length === 0) {
    articleList.innerHTML = '<p style="padding: 16px; text-align: center; color: var(--text-secondary);">No articles found</p>';
  }
}

// Handle theme toggle
function handleThemeToggle() {
  const currentTheme = isFeatureEnabled('ENABLE_PLAYFUL_THEME');
  const newTheme = !currentTheme;
  
  // Toggle theme
  setFeatureFlag('ENABLE_PLAYFUL_THEME', newTheme);
  
  // Save preference to localStorage
  saveThemePreference(newTheme);
  
  // Update UI
  updateStepProgressIndicator();
  
  // Show notification
  const message = newTheme 
    ? 'ðŸŽ¨ Playful theme enabled! Watch the boy jump across stepping stones!'
    : 'ðŸ“‹ Classic theme enabled. Using text progress indicator.';
  showNotification(message);
  
  console.log('[Stepper] Theme toggled:', newTheme ? 'Playful' : 'Classic');
}

// Load theme preference from localStorage
function loadThemePreference() {
  try {
    const saved = localStorage.getItem(THEME_STORAGE_KEY);
    if (saved !== null) {
      const enabled = saved === 'true';
      setFeatureFlag('ENABLE_PLAYFUL_THEME', enabled);
      console.log('[Stepper] Loaded theme preference:', enabled ? 'Playful' : 'Classic');
    }
  } catch (error) {
    console.warn('[Stepper] Could not load theme preference:', error);
  }
}

// Save theme preference to localStorage
function saveThemePreference(enabled) {
  try {
    localStorage.setItem(THEME_STORAGE_KEY, enabled.toString());
    console.log('[Stepper] Saved theme preference:', enabled ? 'Playful' : 'Classic');
  } catch (error) {
    console.warn('[Stepper] Could not save theme preference:', error);
  }
}

// Initialize on load
init();
